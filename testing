Method 1: Testing with a Real VM (Recommended)
Prerequisites:
1. A VM running with serial console configured on TCP port 4555 (or another port)
2. Guest OS configured to use serial console (ttyS0)
Step-by-Step Testing:
1. Start the MCP server:
# Terminal 1 - Start the MCP server
perl sercov.pl
2. Test MCP communication (in another terminal):
# Terminal 2 - Test basic MCP functionality
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | perl sercov.pl
3. Start a bridge for your VM:
# Terminal 2 - Start bridge for VM named "myvm"
echo '{"jsonrpc": "2.0", "id": 2, "method": "tools/call", "params": {"name": "start", "arguments": {"VM_NAME": "myvm", "PORT": 4555}}}' | perl sercov.pl
4. Check bridge status:
echo '{"jsonrpc": "2.0", "id": 3, "method": "tools/call", "params": {"name": "status", "arguments": {"VM_NAME": "myvm"}}}' | perl sercov.pl
5. Read from VM console:
echo '{"jsonrpc": "2.0", "id": 4, "method": "tools/call", "params": {"name": "read", "arguments": {"VM_NAME": "myvm"}}}' | perl sercov.pl
6. Write commands to VM:
echo '{"jsonrpc": "2.0", "id": 5, "method": "tools/call", "params": {"name": "write", "arguments": {"VM_NAME": "myvm", "text": "ls -la"}}}' | perl sercov.pl
Method 2: Testing Without a Real VM (Simulation)
Create a Simple TCP Server to Simulate VM Serial Console:
1. Terminal 1 - Start a mock VM serial console:
# Simple netcat server that echoes back input
while true; do echo "Mock VM Serial Console - Ready"; nc -l -p 4555; done
Or use a more sophisticated Python mock:
# mock_vm.py - Save and run: python3 mock_vm.py
import socket
import time
def mock_vm_serial():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('127.0.0.1', 4555))
    server.listen(1)
    print("Mock VM Serial Console listening on port 4555...")
    
    while True:
        client, addr = server.accept()
        print(f"Connection from {addr}")
        client.send(b"Mock VM Boot Complete\r\nLogin: ")
        
        while True:
            try:
                data = client.recv(1024)
                if not data:
                    break
                command = data.decode().strip()
                print(f"VM received: {command}")
                if command == "exit":
                    client.send(b"Goodbye!\r\n")
                    break
                else:
                    response = f"Command '{command}' executed\r\nVM> "
                    client.send(response.encode())
            except:
                break
        client.close()
if __name__ == "__main__":
    mock_vm_serial()
2. Terminal 2 - Start sercov MCP server:
perl sercov.pl
3. Terminal 3 - Test the integration:
# Start bridge
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "start", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Read initial output
echo '{"jsonrpc": "2.0", "id": 2, "method": "tools/call", "params": {"name": "read", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Send commands
echo '{"jsonrpc": "2.0", "id": 3, "method": "tools/call", "params": {"name": "write", "arguments": {"VM_NAME": "testvm", "text": "whoami"}}}' | perl sercov.pl
Method 3: Direct Unix Socket Testing
The server also creates Unix sockets for direct terminal access:
1. Start the bridge:
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "start", "arguments": {"VM_NAME": "myvm"}}}' | perl sercov.pl
2. Connect directly to the Unix socket:
# Using socat
socat - UNIX-CONNECT:/tmp/serial_myvm
# Using netcat
nc -U /tmp/serial_myvm
Method 4: Automated Test Script
Create a comprehensive test script:
#!/bin/bash
# test_sercov.sh
SERVER_PID=""
VM_MOCK_PID=""
cleanup() {
    echo "Cleaning up..."
    kill $SERVER_PID 2>/dev/null
    kill $VM_MOCK_PID 2>/dev/null
    exit 0
}
trap cleanup INT TERM
# Start mock VM
python3 mock_vm.py &
VM_MOCK_PID=$!
# Start sercov server
perl sercov.pl &
SERVER_PID=$!
sleep 2
# Test sequence
echo "=== Testing sercov MCP server ==="
# Test 1: List tools
echo "Test 1: Listing tools"
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | perl sercov.pl
# Test 2: Start bridge
echo "Test 2: Starting bridge"
echo '{"jsonrpc": "2.0", "id": 2, "method": "tools/call", "params": {"name": "start", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Test 3: Check status
echo "Test 3: Checking status"
echo '{"jsonrpc": "2.0", "id": 3, "method": "tools/call", "params": {"name": "status", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Test 4: Read output
echo "Test 4: Reading output"
echo '{"jsonrpc": "2.0", "id": 4, "method": "tools/call", "params": {"name": "read", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Test 5: Send command
echo "Test 5: Sending command"
echo '{"jsonrpc": "2.0", "id": 5, "method": "tools/call", "params": {"name": "write", "arguments": {"VM_NAME": "testvm", "text": "echo hello"}}}' | perl sercov.pl
sleep 1
# Test 6: Read response
echo "Test 6: Reading response"
echo '{"jsonrpc": "2.0", "id": 6, "method": "tools/call", "params": {"name": "read", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
# Test 7: Stop bridge
echo "Test 7: Stopping bridge"
echo '{"jsonrpc": "2.0", "id": 7, "method": "tools/call", "params": {"name": "stop", "arguments": {"VM_NAME": "testvm"}}}' | perl sercov.pl
echo "=== Tests completed ==="
cleanup
Key Testing Scenarios to Validate:
1. Basic MCP Protocol: initialize, tools/list
2. Bridge Lifecycle: start → status → read/write → stop
3. Error Handling: Invalid VM names, missing parameters
4. Auto-restart: Simulate VM disconnect and verify auto-restart
5. Multiple VMs: Test concurrent bridges for different VMs
6. Performance: High-volume read/write operations
Debug Mode
Enable debug output by setting $DEBUG = 1 at the top of sercov.pl to see detailed logs:
my $DEBUG = 1;  # Enable debug output
This will show all the internal operations and help with troubleshooting.
The most practical approach is starting with the mock VM method to validate the core functionality before testing with real VMs.